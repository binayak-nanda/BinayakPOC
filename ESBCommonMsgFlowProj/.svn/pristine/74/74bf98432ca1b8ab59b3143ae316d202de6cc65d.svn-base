
PATH shared;

DECLARE TraceLevel        EXTERNAL CHARACTER 'NotSet';
DECLARE ServiceName       EXTERNAL CHARACTER 'NotSet';
DECLARE Direction         EXTERNAL CHARACTER 'NotSet';
DECLARE ProjectName       EXTERNAL CHARACTER 'NotSet'; 
DECLARE SourceDestination EXTERNAL CHARACTER 'NotSet';
DECLARE MessageFlow       EXTERNAL CHARACTER 'NotSet';
DECLARE Server            EXTERNAL CHARACTER 'NotSet';
DECLARE QueueManager      EXTERNAL CHARACTER 'NotSet';
DECLARE Broker            EXTERNAL CHARACTER 'NotSet';
DECLARE ExecutionGroup    EXTERNAL CHARACTER 'NotSet';
DECLARE LogPoint          EXTERNAL CHARACTER 'NotSet';
DECLARE LogPayload        EXTERNAL BOOLEAN FALSE;
DECLARE ESBJMSCatchOutputLogicFlag   EXTERNAL BOOLEAN FALSE;
DECLARE ESBMQFailureOutputLogicFlag  EXTERNAL BOOLEAN FALSE;
DECLARE ReplyOnCatchJMS   EXTERNAL BOOLEAN FALSE;
DECLARE ReplyOnFailureJMS EXTERNAL BOOLEAN FALSE;
DECLARE ReplyOnCatchMQ    EXTERNAL BOOLEAN FALSE;
DECLARE ReplyOnFailureMQ  EXTERNAL BOOLEAN FALSE;
DECLARE Rethrow           EXTERNAL BOOLEAN FALSE;
DECLARE OverrideExpiry	  EXTERNAL BOOLEAN FALSE;
DECLARE LogMessageHeader  EXTERNAL BOOLEAN FALSE;

DECLARE soap NAMESPACE 'http://schemas.xmlsoap.org/soap/envelope/';

-- Map the ExceptionList to the common event error structure.
CREATE PROCEDURE LoadProperties(INOUT envRef REFERENCE)
	BEGIN

        SET envRef.Variables.Properties.TraceLevel        = TraceLevel;
		SET envRef.Variables.Properties.ServiceName       = ServiceName;
		SET envRef.Variables.Properties.Direction         = Direction;
		SET envRef.Variables.Properties.ProjectName       = ProjectName;
		SET envRef.Variables.Properties.SourceDestination = SourceDestination;
		SET envRef.Variables.Properties.Server            = Server;
		SET envRef.Variables.Properties.LogMessageHeader  = LogMessageHeader;
		
     
END;

CREATE COMPUTE MODULE CallLoadProperties
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		DECLARE envRef REFERENCE TO Environment;
		
		CALL LoadProperties(envRef);
		
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE SetAnnotationBackoutCountError
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		CALL CopyEntireMessage();
		
		-- Add Backout Count annotation. This usually means that the error is an internal MQInput error (e.g. parsing error)
		-- Copy the body and add annotation.
		
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

-- Map the ExceptionList to the common event error structure.
--CREATE PROCEDURE MapErrorMQToCommonEvent(INOUT envRef REFERENCE, INOUT excpListPath REFERENCE)
--	BEGIN
--
--        DECLARE eventRef REFERENCE TO envRef.ESBEvent.Event;
--        
--		DECLARE i INTEGER 1;
--		
--		/* Loop till the last child */
--		WHILE (CARDINALITY(excpListPath.*[]) > 0) DO
--		
--		    /* Check if exception number is available */
--		    IF (excpListPath.Number IS NOT NULL) THEN
--		
--		        /* Store the current exception details */
--		        SET eventRef.ErrorInfo.Error[i].ServiceName      = 'default';
--		        SET eventRef.ErrorInfo.Error[i].Timestamp        = CURRENT_TIMESTAMP;
--		        SET eventRef.ErrorInfo.Error[i].ErrorCode        = excpListPath.Number;
--		        SET eventRef.ErrorInfo.Error[i].ErrorText        = excpListPath.Text;
--		        SET eventRef.ErrorInfo.Error[i].ErrorSeverity    = excpListPath.Severity;
--		        SET eventRef.ErrorInfo.Error[i].ErrorType        = 'system';
--                CALL ConstructErrorDetailDescription(excpListPath) INTO eventRef.ErrorInfo.Error[i].ErrorDescription;
--                SET eventRef.ErrorInfo.Error[i].ErrorSource      = 'default';
--                SET eventRef.ErrorInfo.Error.InputData VALUE = NULL;
--		        SET eventRef.ErrorInfo.Error.DebugData VALUE = NULL;
--                             
--		    END IF;
--		    
--		    MOVE excpListPath LASTCHILD;
--		    SET i = i + 1;
--		
--		END WHILE;
--
--END;


CREATE COMPUTE MODULE MapMQOutToCommonEvent
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN

		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		
		DECLARE outputRootRef REFERENCE TO OutputRoot;
		DECLARE inputRootRef REFERENCE TO InputRoot;
        DECLARE inputMQMDRef REFERENCE TO InputRoot.MQMD;
        DECLARE inputPropRef REFERENCE TO InputRoot.Properties;

        DECLARE envRef REFERENCE TO Environment;
        
        CALL StoreInputRoot(inputRootRef, envRef);
        CALL LoadProperties(envRef);
        
        -- SET envRef.Variables.Log.CurrentLogPoint = LogPoint; -- Taken from promoted UDP.
       
        SET Environment.Variables.QBE.ESBEvent.Event.Role = 'info';
        
        DECLARE eventRef REFERENCE TO Environment.Variables.QBE.ESBEvent.Event;
        
        CALL MapCommonInfoToCommonEvent(envRef, inputPropRef, outputRootRef);

		SET eventRef.EventSource.UserId VALUE             = inputMQMDRef.UserIdentifier;
		SET eventRef.MessageContext.MessageId             = inputMQMDRef.MsgId;
		SET eventRef.MessageContext.CorrelationId         = inputMQMDRef.CorrelId;
		SET eventRef.MessageContext.Destination.Transport = 'mq';	
		SET eventRef.MessageContext.Destination.Name      = inputMQMDRef.SourceQueue;
		SET eventRef.MessageContext.Destination.Type      = 'queue';

	    /* Copy the message body if it exists. */
--		IF (CARDINALITY(InputBody.*[]) > 0) THEN
--			-- EVAL('SET ' || 'OutputRoot.' || FIELDNAME(InputBody) || ' = InputBody;');
--			SET OutputRoot.{FIELDNAME(InputBody)} = InputBody;
--		END IF;
 
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE MapMQCatchToCommonEvent
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN

		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		
		DECLARE outputRootRef REFERENCE TO OutputRoot;
		DECLARE inputRootRef REFERENCE TO InputRoot;
        DECLARE inputMQMDRef REFERENCE TO InputRoot.MQMD;
        DECLARE inputPropRef REFERENCE TO InputRoot.Properties;
        DECLARE inputBodyRef REFERENCE TO InputBody;
        DECLARE envRef REFERENCE TO Environment;
        DECLARE excpListPath REFERENCE TO InputExceptionList.*[1];
        
        CALL StoreInputRoot(inputRootRef, envRef);
        -- CALL LoadProperties(envRef);
        
        SET Environment.Variables.QBE.ESBEvent.Event.Role = 'error';
        -- SET envRef.Variables.Log.CurrentLogPoint = LogPoint;
        
        DECLARE eventRef REFERENCE TO Environment.Variables.QBE.ESBEvent.Event;
        
        CALL MapCommonInfoToCommonEvent(envRef, inputPropRef, outputRootRef);

        SET eventRef.EventSource.UserId VALUE             = inputMQMDRef.UserIdentifier;
		SET eventRef.MessageContext.MessageId             = inputMQMDRef.MsgId;
		SET eventRef.MessageContext.CorrelationId         = inputMQMDRef.CorrelId;
		SET eventRef.MessageContext.Destination.Transport = 'mq';	
		SET eventRef.MessageContext.Destination.Name      = inputMQMDRef.SourceQueue;
		SET eventRef.MessageContext.Destination.Type      = 'queue';
 		
 		-- SET eventRef.LogPoint  = envRef.Variables.Log.CurrentLogPoint;
 		
 		CALL MapErrorToCommonEvent(envRef, excpListPath);

  	    /* Copy the message body if it exists. */
--		IF (CARDINALITY(InputBody.*[]) > 0) THEN
--			EVAL('SET ' || 'OutputRoot.' || FIELDNAME(InputBody) || ' = InputBody;');
--		END IF;

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;



CREATE COMPUTE MODULE MapMQFailureToCommonEvent
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		
		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		
		DECLARE outputRootRef REFERENCE TO OutputRoot;
		DECLARE inputRootRef REFERENCE TO InputRoot;
        DECLARE inputMQMDRef REFERENCE TO InputRoot.MQMD;
        DECLARE inputPropRef REFERENCE TO InputRoot.Properties;
        -- Cannot create reference to InputRoot directly as it throws an exception.

        DECLARE envRef REFERENCE TO Environment;
        DECLARE excpListPath REFERENCE TO InputExceptionList.*[1];
        
        CALL StoreInputRoot(inputRootRef, envRef);
        CALL LoadProperties(envRef);
        
        SET Environment.Variables.QBE.ESBEvent.Event.Role = 'error';
        
        DECLARE eventRef REFERENCE TO Environment.Variables.QBE.ESBEvent.Event;
        
        CALL MapCommonInfoToCommonEvent(envRef, inputPropRef, outputRootRef);

        SET eventRef.EventSource.UserId VALUE             = inputMQMDRef.UserIdentifier;
		SET eventRef.MessageContext.MessageId             = inputMQMDRef.MsgId;
		SET eventRef.MessageContext.CorrelationId         = inputMQMDRef.CorrelId;
		SET eventRef.MessageContext.Destination.Transport = 'mq';	
		SET eventRef.MessageContext.Destination.Name      = inputMQMDRef.SourceQueue;
		SET eventRef.MessageContext.Destination.Type      = 'queue';
 		
 		CALL MapErrorToCommonEvent(envRef, excpListPath);

  	    /* Copy the message body if it exists. */
--		IF (CARDINALITY(InputBody.*[]) > 0) THEN
--			-- EVAL('SET ' || 'OutputRoot.' || FIELDNAME(InputBody) || ' = InputBody;');
--			CREATE LASTCHILD OF OutputRoot DOMAIN FIELDNAME (InputRoot.*[<]);
-- 			SET OutputRoot.*[<] = InputRoot.*[<];
            
--            SET eventRef.MessageContext.Payload = CAST(InputRoot.BLOB.BLOB AS CHAR CCSID InputRoot.MQMD.CodedCharSetId);
            
            -- SET OutputRoot.BLOB.BLOB = CAST(InputBody AS BLOB CCSID InputRoot.MQMD.CodedCharSetId ENCODING InputRoot.MQMD.Encoding);
--			
--			SET OutputRoot.Properties.MessageDomain = 'BLOB';
--		    SET OutputRoot.Properties.MessageFormat = 'BLOB';

--          SET OutputRoot.Properties.MessageDomain = 'BLOB';
--			SET OutputRoot."BLOB"."BLOB" = BITSTREAM(InputBody);
--			
--			DECLARE outMsg BLOB CAST(InputRoot.MRM AS BLOB CCSID InputRoot.Properties.CodedCharSetId); 
--			SET OutputRoot.Properties.CodedCharSetId = InputRoot.Properties.CodedCharSetId; 
--			SET OutputRoot.Properties.Encoding = InputRoot.Properties.Encoding; 
--			SET OutputRoot.BLOB.BLOB = outMsg;
--			
--			DECLARE yo BLOB ASBITSTREAM(InputRoot.MRM, InputRoot.Properties.Encoding, InputRoot.Properties.CodedCharSetId);
				
--		END IF;

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE ESBMQInput_DefaultESQLModule
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		
		-- CALL CopyMessageHeaders();
		CALL CopyEntireMessage();
		
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

-- This procedure sets up the common ESBEvent structure and populates all the common information available.
CREATE PROCEDURE MapCommonInfoToCommonEvent(INOUT envRef REFERENCE, INOUT inputPropRef REFERENCE, INOUT outputRootRef REFERENCE)
	BEGIN
      
        -- Flag to indicate whether the common info has been mapped to ESBEvent.
        SET envRef.Variables.CommonInfoMappedFlag = FALSE;
        
        DECLARE eventRef REFERENCE TO envRef.Variables.QBE.ESBEvent.Event;
                
 		SET eventRef.Timestamp VALUE                       = CAST(CURRENT_GMTTIMESTAMP AS CHAR FORMAT 'IU');
 		SET eventRef.EventSource.ServiceName VALUE         = envRef.Variables.Properties.ServiceName; -- Gets set in flow specific esql
 		SET eventRef.EventSource.Operation VALUE           = eventRef.EventSource.Operation; -- Gets set in flow specific esql
 		SET eventRef.EventSource.Direction VALUE           = envRef.Variables.Properties.Direction; -- Gets set in flow specific esql
 		SET eventRef.EventSource.Source VALUE              = eventRef.EventSource.Source; -- Gets set in flow specific esql
 		SET eventRef.EventSource.UserId VALUE              = NULL; -- Gets set in flow specific esql
 		SET eventRef.EventSource.ConsumerUserId VALUE      = COALESCE(eventRef.EventSource.ConsumerUserId, '');
 		SET eventRef.EventSource.ProcessName VALUE         = NULL;
 		SET eventRef.EventSource.ProcessInstanceName VALUE = NULL;
 		SET eventRef.EventSource.ProcessId VALUE           = ProcessId;
 		SET eventRef.EventSource.ComponentName VALUE       = MessageFlowLabel;
 		SET eventRef.EventSource.ProjectName VALUE         = envRef.Variables.Properties.ProjectName;
 		SET eventRef.EventSource.QueueManagerName VALUE    = QueueManagerName;
 		SET eventRef.EventSource.BrokerName VALUE          = BrokerName;
 		SET eventRef.EventSource.ExecutionGroup VALUE      = ExecutionGroupLabel;
 		SET eventRef.EventSource.MessageFlowName VALUE     = MessageFlowLabel;
 		SET eventRef.EventSource.TrackingId VALUE          = COALESCE(eventRef.EventSource.TrackingId, '');
 		SET eventRef.EventSource.MessageStatus VALUE       = COALESCE(eventRef.EventSource.MessageStatus, '');
		CREATE FIELD eventRef.EventCorrelation;
		--SET eventRef.EventCorrelation.AppContext[1].Name  = ''; -- Gets set in flow specific esql
		--SET eventRef.EventCorrelation.AppContext[1].Value = '';	-- Gets set in flow specific esql
		
--		SET eventRef.EventCorrelation.TransactionContext.TransactionId   VALUE = NULL;
--		SET eventRef.EventCorrelation.TransactionContext.TransactionName VALUE = NULL;
--		SET eventRef.EventCorrelation.TransactionContext.StartTime       VALUE = NULL;
--		SET eventRef.EventCorrelation.TransactionContext.SourceName      VALUE = NULL;	
	
		SET eventRef.MessageContext.Payload VALUE               = NULL;
		SET eventRef.MessageContext.MessageId VALUE             = NULL;
		SET eventRef.MessageContext.CorrelationId VALUE         = NULL;
		SET eventRef.MessageContext.MessageSet VALUE            = inputPropRef.MessageSet;
		SET eventRef.MessageContext.MessageType VALUE           = inputPropRef.MessageType;
		SET eventRef.MessageContext.MessageFormat VALUE         = inputPropRef.MessageFormat;
		SET eventRef.MessageContext.CCSID VALUE                 = inputPropRef.CodedCharSetId;
		SET eventRef.MessageContext.Encoding VALUE              = inputPropRef.Encoding;
		
		SET eventRef.MessageContext.Destination.Transport VALUE = NULL;
		SET eventRef.MessageContext.Destination.Server VALUE    = envRef.Variables.Properties.Server;
		SET eventRef.MessageContext.Destination.Name VALUE      = NULL;
		SET eventRef.MessageContext.Destination.Type VALUE      = NULL;
		
		SET envRef.Variables.CommonInfoMappedFlag = TRUE;
		
		-- Try to identify the operation
 		DECLARE operation CHARACTER NULL;
 		IF EXISTS(outputRootRef.MRM[]) THEN
 			SET operation = inputPropRef.MessageType; -- e.g. COBOL message name
 		ELSEIF EXISTS(outputRootRef.XMLNSC[]) THEN
 			-- check for SOAP
 			IF EXISTS(outputRootRef.XMLNSC.soap:Envelope.soap:Body.*[]) THEN
 				SET operation = FIELDNAME(outputRootRef.XMLNSC.soap:Envelope.soap:Body.*[>]);
 			ELSE
 				-- plain XML
 				SET operation = FIELDNAME(outputRootRef.XMLNSC.*[>]);
 			END IF;
 		ELSEIF EXISTS(outputRootRef.XMLNS[]) THEN
 			-- check for SOAP
 			IF EXISTS(outputRootRef.XMLNS.soap:Envelope.soap:Body.*[]) THEN
 				SET operation = FIELDNAME(outputRootRef.XMLNS.soap:Envelope.soap:Body.*[>]);
 			ELSE
 				-- plain XML
 				SET operation = FIELDNAME(outputRootRef.XMLNS.*[>]);
 			END IF;
 		END IF;	
 		SET eventRef.EventSource.Operation VALUE = operation;
		
END;

-- Map the ExceptionList to the common event error structure.
CREATE PROCEDURE MapErrorToCommonEvent(INOUT envRef REFERENCE, INOUT excpListPath REFERENCE)
	BEGIN

        DECLARE eventRef REFERENCE TO envRef.Variables.QBE.ESBEvent.Event;
        
		DECLARE i INTEGER 1;
		
		/* Loop till the last child */
		WHILE (CARDINALITY(excpListPath.*[]) > 0) DO
		
		    /* Check if exception number is available */
		    IF (excpListPath.Number IS NOT NULL) THEN
		
		        /* Store the current exception details */
		        SET eventRef.ErrorInfo.Error[i].ServiceName VALUE    = COALESCE(envRef.Variables.Properties.ServiceName, 'default');
		        SET eventRef.ErrorInfo.Error[i].Timestamp VALUE       = CAST(CURRENT_GMTTIMESTAMP AS CHAR FORMAT 'IU');
		        SET eventRef.ErrorInfo.Error[i].ErrorCode VALUE       = excpListPath.Number;
		        SET eventRef.ErrorInfo.Error[i].ErrorText VALUE       = excpListPath.Text;
		        SET eventRef.ErrorInfo.Error[i].ErrorSeverity  VALUE  = excpListPath.Severity;
		        SET eventRef.ErrorInfo.Error[i].ErrorType  VALUE      = 'system';
                CALL ConstructErrorDetailDescription(excpListPath) INTO eventRef.ErrorInfo.Error[i].ErrorDescription;
                IF excpListPath.Label <> '' THEN
                	SET eventRef.ErrorInfo.Error[i].ErrorSource VALUE  = excpListPath.Label;
                ELSE
                	SET eventRef.ErrorInfo.Error[i].ErrorSource VALUE  = 'Exception';
                END IF;
                SET eventRef.ErrorInfo.Error[i].InputData VALUE = NULL;
		        SET eventRef.ErrorInfo.Error[i].DebugData VALUE = NULL;
                             
		    END IF;
		    
		    MOVE excpListPath LASTCHILD;
		    SET i = i + 1;
		
		END WHILE;

END;

-- This procedure populates the ESBEvent structure in the environment and sets the JMS specific fields.
CREATE COMPUTE MODULE MapJMSOutToCommonEvent
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN

		SET OutputRoot = InputRoot;
				
		DECLARE outputRootRef REFERENCE TO OutputRoot;
		DECLARE inputRootRef REFERENCE TO InputRoot;
        DECLARE inputPropRef REFERENCE TO InputRoot.Properties;
        DECLARE inputJMSHdrRef REFERENCE TO InputRoot.JMSTransport.Transport_Folders.Header_Values;
        DECLARE inputJMSTransportRef REFERENCE TO InputRoot.JMSTransport.Transport_Folders;
        DECLARE payloadBlob BLOB '';
        
        DECLARE envRef REFERENCE TO Environment;
        
        CALL StoreInputRoot(inputRootRef, envRef);
        
        CALL LoadProperties(envRef);
        
        SET Environment.Variables.QBE.ESBEvent.Event.Role = 'info';
        
        DECLARE eventRef REFERENCE TO Environment.Variables.QBE.ESBEvent.Event;
        
        CALL MapCommonInfoToCommonEvent(envRef, inputPropRef, outputRootRef);
        
        SET eventRef.EventSource.UserId VALUE             = InputRoot.JMSTransport.Transport_Folders.Standard_Properties.JMSXUserID; -- Gets set in flow specific esql
                
		SET eventRef.MessageContext.MessageId             = inputJMSHdrRef.JMSMessageID;
		SET eventRef.MessageContext.CorrelationId         = inputJMSHdrRef.JMSCorrelationID;
		SET eventRef.MessageContext.Destination.Transport = 'jms';	
		SET eventRef.MessageContext.Destination.Name      = envRef.Variables.Properties.SourceDestination;
		SET eventRef.MessageContext.Destination.Type      = 'queue';

  	    /* Copy the message body if it exists. */
		IF (CARDINALITY(InputBody.*[]) > 0) THEN
			-- SET eventRef.MessageContext.Payload = ASBITSTREAM(InputBody ENCODING InputRoot.Properties.Encoding CCSID InputRoot.Properties.CodedCharSetId);
            -- SET payloadBlob = ASBITSTREAM(InputRoot.*[<] ENCODING InputRoot.Properties.Encoding CCSID InputRoot.Properties.CodedCharSetId); 
			-- DECLARE msgBody BLOB ASBITSTREAM(InputRoot, InputRoot.Properties.Encoding, InputRoot.Properties.CodedCharSetId);
            -- DECLARE charMsgBody CHAR CAST(msgBody AS CHAR CCSID InputProperties.CodedCharSetId); 
			
			-- SET payloadBlob = ASBITSTREAM(InputRoot.*[<] CCSID InputRoot.Properties.CodedCharSetId); 
			-- EVAL('SET ' || 'OutputRoot.' || FIELDNAME(InputBody) || ' = InputBody;');
			SET OutputRoot.{FIELDNAME(InputBody)} = InputBody;
		END IF;
 
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE MapJMSCatchToCommonEvent
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN

		CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		
		DECLARE outputRootRef REFERENCE TO OutputRoot;
		DECLARE inputRootRef REFERENCE TO InputRoot;
        DECLARE inputJMSHdrRef REFERENCE TO InputRoot.JMSTransport.Transport_Folders.Header_Values;
        DECLARE inputPropRef REFERENCE TO InputRoot.Properties;
        DECLARE inputBodyRef REFERENCE TO InputBody;
        DECLARE envRef REFERENCE TO Environment;
        DECLARE excpListPath REFERENCE TO InputExceptionList.*[1];
        
        -- CALL LoadProperties(envRef);
        
        CALL StoreInputRoot(inputRootRef, envRef);
        
        SET Environment.Variables.QBE.ESBEvent.Event.Role = 'error';
        
        DECLARE eventRef REFERENCE TO Environment.Variables.QBE.ESBEvent.Event;
        
        IF (envRef.Variables.CommonInfoMappedFlag <> TRUE) THEN
        	CALL MapCommonInfoToCommonEvent(envRef, inputPropRef, outputRootRef);
        END IF;
 		
        SET eventRef.EventSource.UserId VALUE             = InputRoot.JMSTransport.Transport_Folders.Standard_Properties.JMSXUserID; -- Gets set in flow specific esql
 		SET eventRef.MessageContext.MessageId             = inputJMSHdrRef.JMSMessageID;
		SET eventRef.MessageContext.CorrelationId         = inputJMSHdrRef.JMSCorrelationID;
		SET eventRef.MessageContext.Destination.Transport = 'jms';	
		SET eventRef.MessageContext.Destination.Name      = envRef.Variables.Properties.SourceDestination;
		SET eventRef.MessageContext.Destination.Type      = 'queue';
 		
 		CALL MapErrorToCommonEvent(envRef, excpListPath);

  	    /* Copy the message body if it exists. */
		IF (CARDINALITY(InputBody.*[]) > 0) THEN
			-- EVAL('SET ' || 'OutputRoot.' || FIELDNAME(InputBody) || ' = InputBody;');
			SET OutputRoot.{FIELDNAME(InputBody)} = InputBody;
		END IF;

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE MapJMSFailureToCommonEvent
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		
		CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		
		DECLARE outputRootRef REFERENCE TO OutputRoot;
		DECLARE inputRootRef REFERENCE TO InputRoot;
        DECLARE inputJMSHdrRef REFERENCE TO InputRoot.JMSTransport.Transport_Folders.Header_Values;
        DECLARE inputPropRef REFERENCE TO InputRoot.Properties;
        -- Cannot create reference to InputRoot directly as it throws an exception.

        DECLARE envRef REFERENCE TO Environment;
        DECLARE excpListPath REFERENCE TO InputExceptionList.*[1];
        
        CALL StoreInputRoot(inputRootRef, envRef);
        CALL LoadProperties(envRef);
        
        SET Environment.Variables.QBE.ESBEvent.Event.Role = 'error';
        
        DECLARE eventRef REFERENCE TO Environment.Variables.QBE.ESBEvent.Event;
        
        CALL MapCommonInfoToCommonEvent(envRef, inputPropRef, outputRootRef);

        SET eventRef.EventSource.UserId VALUE             = InputRoot.JMSTransport.Transport_Folders.Standard_Properties.JMSXUserID; -- Gets set in flow specific esql
		SET eventRef.MessageContext.MessageId             = inputJMSHdrRef.JMSMessageID;
		SET eventRef.MessageContext.CorrelationId         = inputJMSHdrRef.JMSCorrelationID;
		SET eventRef.MessageContext.Destination.Transport = 'jms';	
		SET eventRef.MessageContext.Destination.Name      = envRef.Variables.Properties.SourceDestination;
		SET eventRef.MessageContext.Destination.Type      = 'queue';
        
 		CALL MapErrorToCommonEvent(envRef, excpListPath);

  	    /* Copy the message body if it exists. */
		IF (CARDINALITY(InputBody.*[]) > 0) THEN
			-- EVAL('SET ' || 'OutputRoot.' || FIELDNAME(InputBody) || ' = InputBody;');
			SET OutputRoot.{FIELDNAME(InputBody)} = InputBody;
		END IF;

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE ESBJMSInput_DefaultESQLModule
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		
		-- CALL CopyMessageHeaders();
		CALL CopyEntireMessage();
		
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE OverrideMessageExpiry
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN

		CALL CopyEntireMessage();
		IF OverrideExpiry THEN
			SET OutputRoot.MQMD.Expiry = -1;		
		END IF;
		RETURN TRUE;
	END;
	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;
